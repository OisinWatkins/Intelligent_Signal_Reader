import numpy as np
import scipy.io as io
from itertools import cycle

"""
Test case for read_radar_data after running all bar the network building bit of Simple_Dense_Network.py

for i, output in enumerate(train_gen):
    print(i)
    print('\n')
    if i == 5:
        break

"""


def read_radar_data(files: list, example_shape: tuple, output_format: str = 'MagAng', shuffle: bool = False,
                    batch_size: int = 5, verbose: bool = False):
    """
    read_radar_data is a generator for the simulated RADAR data generated using MATLAB and saved into .mat files.
    Read_RADAR_Data yields the batch of samples and targets, either shuffled or unshuffled. It also ensures there are no
    nan or inf values going to the network

    :param files: List object containing the file paths of each .mat file needed as strings
    :param example_shape: Tuple object containing the shape of a single presentation
    :param output_format: String governing the return format for the data gathered from each file, given that it is
    complex data it can be presented multiple ways.
    :param shuffle: Boolean value governing whether or not the returned batch of presentations is shuffled
    :param batch_size: Integer governing the number of presentations in a single batch
    :param verbose: Boolean value governing the printing of information regarding the status of the generator
    :return: A batch of presentations (inputs and outputs) stored either in the order they were read in or randomly ordered
    """

    # Prepare a batch_file_data generator object
    batch_prepare_gen = batch_file_data(files, example_shape, output_format, batch_size, verbose)

    # Gather batch data from the batch_prepare_gen indefinitely
    for batch_info in batch_prepare_gen:
        # When gathering data ensure there are no inf or nan values present
        samples = np.nan_to_num(batch_info[0])
        targets = np.nan_to_num(batch_info[1])

        # If shuffle is true, store the state of the RGN, shuffle the samples, then return the RGN to the previous state
        # before shuffling the targets. Restoring the previous state of the RGN ensures the target indices still
        # correspond to the sample indices.
        if shuffle:
            rng_state = np.random.get_state()
            np.random.shuffle(samples)
            np.random.set_state(rng_state)
            np.random.shuffle(targets)

        # If verbose is true, print info regarding the current batch read
        if verbose:
            print('targets:\n', targets)
            print('samples shape: ', samples.shape)
            print('targets shape: ', targets.shape)
            print('\n')

        # Yield the batch samples and targets
        yield samples, targets


def batch_file_data(files: list, example_shape: tuple, output_format: str, batch_size: int, verbose: bool = False):
    """
    batch_file_data is a generator which takes the information generated by prepare_data and organises it into batches
    as keras requires. It yields the batch of presentations and targets indefinitely

    :param files: List object containing the file paths of each .mat file needed as strings
    :param example_shape: Tuple object containing the shape of a single presentation
    :param output_format: String governing the return format for the data gathered from each file, given that it is
    complex data it can be presented multiple ways.
    :param batch_size: Integer governing the number of presentations in a single batch
    :param verbose: Boolean value governing the printing of information regarding the status of the generator
    :return: A batch of presentations (inputs and outputs) stored in the order they were read in
    """

    # Prepare an object of the prepare_data generator
    file_read_gen = prepare_data(files, example_shape, output_format, verbose)
    while True:

        # Initialise the return batch inputs and outputs as zeros
        batch_samples = np.zeros((batch_size, example_shape[0], example_shape[1], 2))
        batch_targets = np.zeros((batch_size, 3))

        # Gather a single batch of data out of the file_read_gen and store all presentations sequentially
        for i, data in enumerate(file_read_gen):
            if i == batch_size:
                break
            batch_samples[i, :, :, :] = data[0]
            batch_targets[i, :] = data[1]

        # If verbose is true, print info regarding the current batch read
        if verbose:
            print('batch_targets:\n', batch_targets)
            print('batch_samples shape: ', batch_samples.shape)
            print('batch_targets shape: ', batch_targets.shape)
            print('\n')

        # Yield the current batch
        yield batch_samples, batch_targets


def prepare_data(files: list, example_shape: tuple, output_format: str, verbose: bool = False):
    """
    prepare_data is a generator which handles all the file reading required for training purposes. It yields the sample
    data and target information of individual files indefinitely.

    :param files: List object containing the file paths of each .mat file needed as strings
    :param example_shape: Tuple object containing the shape of a single presentation
    :param output_format: String governing the return format for the data gathered from each file, given that it is
    complex data it can be presented multiple ways.
    :param verbose: Boolean value governing the printing of information regarding the status of the generator
    :return: A single presentation (input and expected output) as numpy arrays arranged according to the output_format
    param
    """

    # Initialise return values
    data_set = np.zeros((example_shape[0], example_shape[1], 2)).astype(np.float_)
    data_targets = np.zeros((1, 3))
    index = 0

    # Step through each file in turn, using cycle to ensure the generator never stops reading files
    for file in cycle(files):
        # Read data from the current file
        data = io.loadmat(file)["RADAR_Data"].astype(np.complex_)

        # Prepare output data based on the output_format parameter
        if output_format == 'ReIm':
            data_set[:, :, 0] = data.real.astype(np.float_)
            data_set[:, :, 1] = data.imag.astype(np.float_)
        else:  # output_format == 'MagAng':
            data_set[:, :, 0] = np.sqrt(np.add(np.power(data.real, 2), np.power(data.imag, 2))).astype(np.float_)
            data_set[:, :, 1] = np.divide(np.array(np.angle(data, deg=True)), 360).astype(np.float_)

        # Split the filename apart to gather the expected output values
        info = file.split("Target_Data\\")[1]
        truth = info.split("_")

        range_str = np.array(truth[0][0:-1])
        angle_str = np.array(truth[1][0:-3])
        velocity_str = np.array(truth[2][0:-7])

        # Store these expected outputs in the targets array as floating point numbers
        data_targets[0, 0] = range_str.astype(np.float_)
        data_targets[0, 1] = angle_str.astype(np.float_)
        data_targets[0, 2] = velocity_str.astype(np.float_)

        # Ensure the index value is always representative of the actual file index
        if index == len(files):
            index = 0

        # If verbose is true, print info regarding the current file read
        if verbose:
            print('File Index: ', index)
            print('data_targets:\n ', data_targets)
            print('data_set shape: ', data_set.shape)
            print('data_targets shape', data_targets.shape)

        # Increment index and yield presentation data
        index += 1

        yield data_set, data_targets
